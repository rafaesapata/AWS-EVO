import type { AuthorizedEvent, LambdaContext, APIGatewayProxyResultV2 } from '../../types/lambda.js';
import { logger } from '../../lib/logging.js';
import { getPrismaClient } from '../../lib/database.js';
import { getUserFromEvent, getOrganizationId } from '../../lib/auth.js';
import { success, error, badRequest, notFound, corsOptions } from '../../lib/response.js';
import { getOrigin } from '../../lib/middleware.js';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

const s3Client = new S3Client({});

interface ExportRequest {
  scanId: string;
  format?: 'detailed' | 'summary' | 'executive';
  includeRemediation?: boolean;
  language?: 'pt-BR' | 'en-US';
}

export async function handler(
  event: AuthorizedEvent,
  context: LambdaContext
): Promise<APIGatewayProxyResultV2> {
  const origin = getOrigin(event);
  const httpMethod = event.httpMethod || event.requestContext?.http?.method;
  
  if (httpMethod === 'OPTIONS') {
    return corsOptions(origin);
  }

  let organizationId: string;
  let userId: string;
  
  try {
    const user = getUserFromEvent(event);
    userId = user.sub || user.id || 'unknown';
    organizationId = getOrganizationId(user);
  } catch (authError) {
    logger.error('Authentication error', authError);
    return error('Unauthorized', 401, undefined, origin);
  }

  try {
    const prisma = getPrismaClient();
    const body: ExportRequest = JSON.parse(event.body || '{}');
    const { scanId, format = 'detailed', includeRemediation = true, language = 'pt-BR' } = body;

    if (!scanId) {
      return badRequest('scanId is required', undefined, origin);
    }


    // Buscar scan - FILTRAR POR ORGANIZATION_ID
    const scan = await prisma.securityScan.findFirst({
      where: { 
        id: scanId,
        organization_id: organizationId  // CRITICAL: Multi-tenancy filter
      }
    });

    if (!scan) {
      return notFound('Scan not found', origin);
    }

    // Buscar findings do scan
    const findings = await prisma.finding.findMany({
      where: {
        organization_id: organizationId,
        scan_type: scan.scan_type
      },
      orderBy: { severity: 'desc' }
    });

    // Gerar conteúdo do PDF
    const pdfContent = generatePDFContent(scan, findings, format, includeRemediation, language);
    const pdfBuffer = Buffer.from(pdfContent, 'utf-8');

    // Upload para S3
    const bucket = process.env.REPORTS_BUCKET || 'evo-uds-reports';
    const key = `security-scans/${organizationId}/${scanId}/${Date.now()}-report.pdf`;

    await s3Client.send(new PutObjectCommand({
      Bucket: bucket,
      Key: key,
      Body: pdfBuffer,
      ContentType: 'application/pdf',
      Metadata: { scanId, format, generatedBy: userId, generatedAt: new Date().toISOString() }
    }));

    const signedUrl = await getSignedUrl(
      s3Client,
      new PutObjectCommand({ Bucket: bucket, Key: key }),
      { expiresIn: 3600 }
    );

    await prisma.reportExport.create({
      data: {
        organization_id: organizationId,
        report_type: 'security_scan',
        format: 'pdf',
        status: 'completed',
        file_url: signedUrl,
        file_size: pdfBuffer.length
      }
    });

    return success({
      downloadUrl: signedUrl,
      expiresIn: 3600,
      fileSize: pdfBuffer.length,
      format
    }, 200, origin);
  } catch (err) {
    logger.error('Security scan PDF export error:', err);
    return error('Internal server error', 500, undefined, origin);
  }
}

function generatePDFContent(
  scan: any,
  findings: any[],
  format: string,
  includeRemediation: boolean,
  language: string
): string {
  const t = language === 'pt-BR' ? {
    title: 'Relatório de Segurança',
    summary: 'Resumo Executivo',
    severity: 'Severidade',
    count: 'Quantidade',
    findings: 'Descobertas',
    resource: 'Recurso',
    remediation: 'Remediação',
    generatedBy: 'Gerado por'
  } : {
    title: 'Security Report',
    summary: 'Executive Summary',
    severity: 'Severity',
    count: 'Count',
    findings: 'Findings',
    resource: 'Resource',
    remediation: 'Remediation',
    generatedBy: 'Generated by'
  };

  const counts = {
    CRITICAL: findings.filter(f => f.severity === 'CRITICAL').length,
    HIGH: findings.filter(f => f.severity === 'HIGH').length,
    MEDIUM: findings.filter(f => f.severity === 'MEDIUM').length,
    LOW: findings.filter(f => f.severity === 'LOW').length
  };

  let html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>${t.title}</title></head><body>
<h1>${t.title}</h1>
<p>Scan ID: ${scan.id}</p>
<p>Type: ${scan.scan_type}</p>
<p>Status: ${scan.status}</p>
<h2>${t.summary}</h2>
<table><tr><th>${t.severity}</th><th>${t.count}</th></tr>
<tr><td>CRITICAL</td><td>${counts.CRITICAL}</td></tr>
<tr><td>HIGH</td><td>${counts.HIGH}</td></tr>
<tr><td>MEDIUM</td><td>${counts.MEDIUM}</td></tr>
<tr><td>LOW</td><td>${counts.LOW}</td></tr>
<tr><td>Total</td><td>${findings.length}</td></tr></table>`;

  if (format !== 'executive') {
    html += `<h2>${t.findings}</h2>`;
    for (const f of findings) {
      html += `<div><strong>${f.description}</strong> [${f.severity}]`;
      if (f.resource_id) html += `<p>${t.resource}: ${f.resource_id}</p>`;
      if (includeRemediation && f.remediation) html += `<p>${t.remediation}: ${f.remediation}</p>`;
      html += `</div>`;
    }
  }

  html += `<footer>${t.generatedBy} EVO UDS - ${new Date().toISOString()}</footer></body></html>`;
  return html;
}
