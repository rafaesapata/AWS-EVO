AWSTemplateFormatVersion: '2010-09-09'
Description: 'EVO UDS - Complete Infrastructure Stack v2 - Fixed CORS and Endpoints'

Parameters:
  Environment:
    Type: String
    Default: production
  ProjectName:
    Type: String
    Default: evo-uds
  SubDomain:
    Type: String
    Default: evo
  HostedZoneId:
    Type: String
    Default: Z025830736D37OCK2Z2QR
  DomainName:
    Type: String
    Default: ai.udstec.io
  CertificateArn:
    Type: String
    Default: arn:aws:acm:us-east-1:383234048592:certificate/4243e02e-ee0c-4b7a-b5b4-bca7adf31a70
  AdminEmail:
    Type: String
    Default: admin@udstec.io

Resources:
  #############################################################################
  # COGNITO
  #############################################################################
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub '${ProjectName}-${Environment}-users'
      UsernameAttributes: [email]
      AutoVerifiedAttributes: [email]
      MfaConfiguration: 'OFF'
      Schema:
        - Name: email
          AttributeDataType: String
          Required: true
          Mutable: true
        - Name: name
          AttributeDataType: String
          Required: false
          Mutable: true
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireUppercase: true
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: false
      AccountRecoverySetting:
        RecoveryMechanisms:
          - Name: verified_email
            Priority: 1

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: !Sub '${ProjectName}-${Environment}-client'
      UserPoolId: !Ref UserPool
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_USER_SRP_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
        - ALLOW_USER_PASSWORD_AUTH
      PreventUserExistenceErrors: ENABLED
      RefreshTokenValidity: 30
      AccessTokenValidity: 1
      IdTokenValidity: 1
      TokenValidityUnits:
        RefreshToken: days
        AccessToken: hours
        IdToken: hours

  UserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      Domain: !Sub '${ProjectName}-${Environment}-${AWS::AccountId}'
      UserPoolId: !Ref UserPool

  AdminGroup:
    Type: AWS::Cognito::UserPoolGroup
    Properties:
      GroupName: admin
      UserPoolId: !Ref UserPool
      Precedence: 1

  UserGroup:
    Type: AWS::Cognito::UserPoolGroup
    Properties:
      GroupName: user
      UserPoolId: !Ref UserPool
      Precedence: 10

  #############################################################################
  # DYNAMODB
  #############################################################################
  OrganizationsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${ProjectName}-${Environment}-organizations'
      BillingMode: PAY_PER_REQUEST
      SSESpecification:
        SSEEnabled: true
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
        - AttributeName: slug
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: slug-index
          KeySchema:
            - AttributeName: slug
              KeyType: HASH
          Projection:
            ProjectionType: ALL

  ProfilesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${ProjectName}-${Environment}-profiles'
      BillingMode: PAY_PER_REQUEST
      SSESpecification:
        SSEEnabled: true
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
        - AttributeName: user_id
          AttributeType: S
        - AttributeName: organization_id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: user-id-index
          KeySchema:
            - AttributeName: user_id
              KeyType: HASH
          Projection:
            ProjectionType: ALL
        - IndexName: organization-id-index
          KeySchema:
            - AttributeName: organization_id
              KeyType: HASH
          Projection:
            ProjectionType: ALL

  #############################################################################
  # IAM ROLE
  #############################################################################
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-${Environment}-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt OrganizationsTable.Arn
                  - !Sub '${OrganizationsTable.Arn}/index/*'
                  - !GetAtt ProfilesTable.Arn
                  - !Sub '${ProfilesTable.Arn}/index/*'
        - PolicyName: CognitoAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cognito-idp:AdminGetUser
                  - cognito-idp:AdminCreateUser
                  - cognito-idp:AdminSetUserPassword
                  - cognito-idp:AdminAddUserToGroup
                  - cognito-idp:AdminUpdateUserAttributes
                  - cognito-idp:ListUsers
                Resource: !GetAtt UserPool.Arn

  #############################################################################
  # LAMBDA FUNCTIONS
  #############################################################################
  HealthCheckFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${Environment}-health'
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 256
      Code:
        ZipFile: |
          import json
          def handler(event, context):
              return {
                  'statusCode': 200,
                  'headers': {
                      'Content-Type': 'application/json',
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token',
                      'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                  },
                  'body': json.dumps({'status': 'healthy', 'service': 'evo-uds-api', 'version': '2.0.0'})
              }

  ProfilesCheckFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${Environment}-profiles-check'
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          PROFILES_TABLE: !Ref ProfilesTable
          ORGANIZATIONS_TABLE: !Ref OrganizationsTable
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          
          dynamodb = boto3.resource('dynamodb')
          
          def handler(event, context):
              headers = {
                  'Content-Type': 'application/json',
                  'Access-Control-Allow-Origin': '*',
                  'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token',
                  'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
              }
              
              try:
                  body = json.loads(event.get('body', '{}'))
                  user_id = body.get('userId') or body.get('user_id')
                  
                  if not user_id:
                      return {'statusCode': 400, 'headers': headers, 'body': json.dumps({'error': 'userId is required'})}
                  
                  profile_table = dynamodb.Table(os.environ['PROFILES_TABLE'])
                  
                  response = profile_table.query(
                      IndexName='user-id-index',
                      KeyConditionExpression='user_id = :uid',
                      ExpressionAttributeValues={':uid': user_id}
                  )
                  
                  profiles = response.get('Items', [])
                  has_org = len(profiles) > 0 and profiles[0].get('organization_id')
                  
                  result = {
                      'hasOrganization': has_org,
                      'profile': profiles[0] if profiles else None
                  }
                  
                  if has_org:
                      org_table = dynamodb.Table(os.environ['ORGANIZATIONS_TABLE'])
                      org_response = org_table.get_item(Key={'id': profiles[0]['organization_id']})
                      result['organization'] = org_response.get('Item')
                  
                  return {'statusCode': 200, 'headers': headers, 'body': json.dumps(result)}
              except Exception as e:
                  return {'statusCode': 500, 'headers': headers, 'body': json.dumps({'error': str(e)})}


  ProfilesCreateWithOrgFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${Environment}-profiles-create-org'
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          PROFILES_TABLE: !Ref ProfilesTable
          ORGANIZATIONS_TABLE: !Ref OrganizationsTable
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import uuid
          from datetime import datetime
          
          dynamodb = boto3.resource('dynamodb')
          
          def handler(event, context):
              headers = {
                  'Content-Type': 'application/json',
                  'Access-Control-Allow-Origin': '*',
                  'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token',
                  'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
              }
              
              try:
                  body = json.loads(event.get('body', '{}'))
                  user_id = body.get('userId') or body.get('user_id')
                  user_email = body.get('email', '')
                  user_name = body.get('name', '')
                  org_name = body.get('organizationName', 'UDS')
                  org_slug = body.get('organizationSlug', 'uds')
                  
                  if not user_id:
                      return {'statusCode': 400, 'headers': headers, 'body': json.dumps({'error': 'userId is required'})}
                  
                  org_table = dynamodb.Table(os.environ['ORGANIZATIONS_TABLE'])
                  profile_table = dynamodb.Table(os.environ['PROFILES_TABLE'])
                  now = datetime.utcnow().isoformat()
                  
                  # Check if org exists by slug
                  existing_org = org_table.query(
                      IndexName='slug-index',
                      KeyConditionExpression='slug = :slug',
                      ExpressionAttributeValues={':slug': org_slug}
                  )
                  
                  if existing_org.get('Items'):
                      org = existing_org['Items'][0]
                      org_id = org['id']
                  else:
                      # Create new organization
                      org_id = str(uuid.uuid4())
                      org_table.put_item(Item={
                          'id': org_id,
                          'name': org_name,
                          'slug': org_slug,
                          'created_at': now,
                          'updated_at': now,
                          'owner_id': user_id,
                          'status': 'active'
                      })
                  
                  # Check if profile exists
                  existing_profile = profile_table.query(
                      IndexName='user-id-index',
                      KeyConditionExpression='user_id = :uid',
                      ExpressionAttributeValues={':uid': user_id}
                  )
                  
                  if existing_profile.get('Items'):
                      profile = existing_profile['Items'][0]
                      profile_table.update_item(
                          Key={'id': profile['id']},
                          UpdateExpression='SET organization_id = :oid, updated_at = :now',
                          ExpressionAttributeValues={':oid': org_id, ':now': now}
                      )
                      profile_id = profile['id']
                  else:
                      profile_id = str(uuid.uuid4())
                      profile_table.put_item(Item={
                          'id': profile_id,
                          'user_id': user_id,
                          'organization_id': org_id,
                          'email': user_email,
                          'name': user_name,
                          'role': 'admin',
                          'created_at': now,
                          'updated_at': now
                      })
                  
                  return {
                      'statusCode': 201,
                      'headers': headers,
                      'body': json.dumps({
                          'success': True,
                          'profile': {'id': profile_id, 'organization_id': org_id},
                          'organization': {'id': org_id, 'name': org_name, 'slug': org_slug}
                      })
                  }
              except Exception as e:
                  return {'statusCode': 500, 'headers': headers, 'body': json.dumps({'error': str(e)})}

  #############################################################################
  # API GATEWAY
  #############################################################################
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub '${ProjectName}-${Environment}-api'
      Description: EVO UDS API

  # /api resource
  ApiResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: api

  # /api/health
  ApiHealthResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiResource
      PathPart: health

  ApiHealthGet:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiHealthResource
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${HealthCheckFunction.Arn}/invocations'

  ApiHealthOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiHealthResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  # /api/profiles
  ApiProfilesResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiResource
      PathPart: profiles

  # /api/profiles/check
  ApiProfilesCheckResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiProfilesResource
      PathPart: check

  ApiProfilesCheckPost:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiProfilesCheckResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ProfilesCheckFunction.Arn}/invocations'

  ApiProfilesCheckOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiProfilesCheckResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  # /api/profiles/create-with-org
  ApiProfilesCreateOrgResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiProfilesResource
      PathPart: create-with-org

  ApiProfilesCreateOrgPost:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiProfilesCreateOrgResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ProfilesCreateWithOrgFunction.Arn}/invocations'

  ApiProfilesCreateOrgOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiProfilesCreateOrgResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true


  #############################################################################
  # LAMBDA PERMISSIONS
  #############################################################################
  HealthLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref HealthCheckFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*'

  ProfilesCheckLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ProfilesCheckFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*'

  ProfilesCreateOrgLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ProfilesCreateWithOrgFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*'

  #############################################################################
  # API DEPLOYMENT
  #############################################################################
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - ApiHealthGet
      - ApiHealthOptions
      - ApiProfilesCheckPost
      - ApiProfilesCheckOptions
      - ApiProfilesCreateOrgPost
      - ApiProfilesCreateOrgOptions
    Properties:
      RestApiId: !Ref ApiGateway

  ApiStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      StageName: prod
      RestApiId: !Ref ApiGateway
      DeploymentId: !Ref ApiDeployment

  #############################################################################
  # CUSTOM DOMAIN
  #############################################################################
  ApiCustomDomain:
    Type: AWS::ApiGateway::DomainName
    Properties:
      DomainName: !Sub 'api-${SubDomain}.${DomainName}'
      RegionalCertificateArn: !Ref CertificateArn
      EndpointConfiguration:
        Types: [REGIONAL]
      SecurityPolicy: TLS_1_2

  ApiBasePathMapping:
    Type: AWS::ApiGateway::BasePathMapping
    DependsOn: ApiStage
    Properties:
      DomainName: !Ref ApiCustomDomain
      RestApiId: !Ref ApiGateway
      Stage: prod

  ApiDnsRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub 'api-${SubDomain}.${DomainName}'
      Type: A
      AliasTarget:
        DNSName: !GetAtt ApiCustomDomain.RegionalDomainName
        HostedZoneId: !GetAtt ApiCustomDomain.RegionalHostedZoneId

  #############################################################################
  # S3 + CLOUDFRONT
  #############################################################################
  FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${ProjectName}-${Environment}-frontend-${AWS::AccountId}'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  CloudFrontOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub '${ProjectName}-${Environment}-oac'
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub '${FrontendBucket.Arn}/*'
            Condition:
              StringEquals:
                'AWS:SourceArn': !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}'

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultRootObject: index.html
        HttpVersion: http2and3
        PriceClass: PriceClass_100
        Aliases:
          - !Sub '${SubDomain}.${DomainName}'
        ViewerCertificate:
          AcmCertificateArn: !Ref CertificateArn
          SslSupportMethod: sni-only
          MinimumProtocolVersion: TLSv1.2_2021
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt FrontendBucket.RegionalDomainName
            OriginAccessControlId: !Ref CloudFrontOAC
            S3OriginConfig:
              OriginAccessIdentity: ''
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: [GET, HEAD, OPTIONS]
          CachedMethods: [GET, HEAD]
          Compress: true
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6
        CustomErrorResponses:
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
            ErrorCachingMinTTL: 300
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
            ErrorCachingMinTTL: 300

  FrontendDnsRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub '${SubDomain}.${DomainName}'
      Type: A
      AliasTarget:
        DNSName: !GetAtt CloudFrontDistribution.DomainName
        HostedZoneId: Z2FDTNDATAQYW2

#############################################################################
# OUTPUTS
#############################################################################
Outputs:
  UserPoolId:
    Value: !Ref UserPool
  UserPoolClientId:
    Value: !Ref UserPoolClient
  ApiGatewayUrl:
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod'
  ApiCustomDomainUrl:
    Value: !Sub 'https://api-${SubDomain}.${DomainName}'
  FrontendUrl:
    Value: !Sub 'https://${SubDomain}.${DomainName}'
  FrontendBucketName:
    Value: !Ref FrontendBucket
  CloudFrontDistributionId:
    Value: !Ref CloudFrontDistribution
